[{"content":"A different way of looking at web apps In April 2022, AWS quietly announced support for Function URLs for Lambda. Function URLs allows for innovation of the function using a generated URL. You can use this run dynamic back end code and return JSON or synthesised HTML, using a template engine like Jinja. While AWS try not to undercut their API Gateway service, this service is really useful for complex web applications right through to very small utility applications. Using the AWS free tier carefully you can host web applications for close-to-free, so its well worth investigating.\nOne problem you will run into is that you will want to run these with an easy to remember URL and to do so with a certificate to match the friendly name, this is where CloudFront and Certificate Manager comes in.\nThe Lambda Function You can build out a Lambda function in CDK in a standard way, in this example I am building a Python based function using some self created layers for Jinja2 and Requests. The application is fairly simple, it takes pass path, does a lookup in DynamoDB and returns information based on a Jinja HTML template, all within the one function.\nconst WebInterfaceFunction = new lambda.Function(this, \u0026#39;WebInterfaceFunction\u0026#39;, {\rcode: lambda.Code.fromAsset(path.join(__dirname, \u0026#39;../lambda/web-interface\u0026#39;)),\rhandler: \u0026#39;main.handler\u0026#39;,\rlayers: [simpleJsonLayer, requestsLayer, jinja2Layer],\rruntime: lambda.Runtime.PYTHON_3_9,\rtimeout: cdk.Duration.seconds(3),\rarchitecture: lambda.Architecture.ARM_64,\renvironment: {\rDYNAMODB_TABLE : webAppTable.tableName\r},\rlogRetention: logs.RetentionDays.ONE_WEEK,\r}); Add a Function URL Now add the Function URL to the function, in this case I am running with no auth, meaning anyone can call for the function. Function URLs also support IAM SigV4 authentication if you have this requirement.\nconst WebInterfaceFunctionUrl = WebInterfaceFunction.addFunctionUrl({\rauthType: lambda.FunctionUrlAuthType.NONE,\r}); A point to note here is that CloudFront has a lot of requirements on the us-east-1 region whilst you may deploy this function in a region closer to home. A way to mitigate this is to post the generated URL to a SSM Parameter for later reference in a us-east-1 stack that will deploy CloudFront. CDK SSM Parameters do not currently support region specificity so you can mitigate this by using the @pepperize/cdk-ssm-parameters-cross-region library. In this example I wrangle the host name from the tokenised URL and sent it to a region specific SSM parameter using the aforementioned library.\nconst functionHostUrl = cdk.Fn.select(2, cdk.Fn.split(\u0026#39;/\u0026#39;, WebInterfaceFunctionUrl.url));\rnew ssmcross.StringParameter(this, \u0026#34;WebInterfaceFunctionHostUrlSsmParam\u0026#34;, {\rregion: \u0026#34;eu-west-1\u0026#34;,\rparameterName: \u0026#34;/webapp/functionurlhost\u0026#34;,\rstringValue: functionHostUrl,\r}); The CloudFront Distribution Now we have a function with an randomly generated AWS URL, hosted in eu-west-1, lets give it a friendly name, a certificate and a CloudFront distribution.\nIn this example I have manually created the ACM certificate and referencing the ARN as an environment variable, you can use CDK to do this automatically at build time.\nconst arn : string = process.env.CERTIFICATE_ARN!;\rconst webAppAcmCertificate = acm.Certificate.fromCertificateArn(this, \u0026#39;WebAppAcmCertificate\u0026#39;, arn); Then we pull the SSM parameter from eu-west-1 using the same library as above.\nconst originUrl = ssmcross.StringParameter.fromStringParameterName(this, \u0026#34;OriginUrl\u0026#34;, \u0026#34;eu-west-1\u0026#34;, \u0026#34;/webapp/functionurlhost\u0026#34;); Lastly we build the CloudFront distribution, target the Function URL and disabled caching (my function is all dynamic content).\nconst busCloudFrontDistro = new CloudFront.Distribution(this, \u0026#39;busCFDistribution\u0026#39;, {\rdefaultBehavior: { origin: new origins.HttpOrigin(originUrl.stringValue),\rcachePolicy: CloudFront.CachePolicy.CACHING_DISABLED\r},\rdomainNames: [\u0026#39;webapp.rstu.xyz\u0026#39;],\rcertificate: webAppAcmCertificate\r}); ","permalink":"https://blog.rstu.xyz/posts/cdk-cloudfront-to-lambda-function/","summary":"Put CloudFront infront of Lambda Function URLs using CDK","title":"CloudFront and Lambda Function URLs"},{"content":"Automate budget visibility when using cloud A good starting position with any new AWS account is to decide a budget for spend and to get notifications in place as you meet, approach or exceed this threshold. AWS provide some predictive analysis of you spend patterns too and can catch early problems before they spiral into bill shock and you are contacting their support teams with the begging bowl.\nHere is a snippet to quickly set up a $100 budget in CDK.\nconst awsBudgetTopic = new sns.Topic(this, \u0026#39;BudgetSnsTopic\u0026#39;, {\rdisplayName: \u0026#39;My AWS Budget\u0026#39;,\r});\rawsBudgetTopic.addSubscription(new subscriptions.EmailSubscription(\r\u0026#39;joe@bloggs.com\u0026#39;\r))\rconst cfnBudgetProps : budgets.CfnBudgetProps = {\rbudget: {\rtimeUnit: \u0026#39;MONTHLY\u0026#39;,\rbudgetType: \u0026#39;COST\u0026#39;,\rbudgetName: \u0026#39;Base Budget\u0026#39;,\rbudgetLimit: {\ramount: 100,\runit: \u0026#39;USD\u0026#39;,\r}\r},\rnotificationsWithSubscribers: [\r{\rnotification: {\rnotificationType: \u0026#39;ACTUAL\u0026#39;,\rcomparisonOperator: \u0026#39;GREATER_THAN\u0026#39;,\rthreshold: 80,\rthresholdType: \u0026#39;PERCENTAGE\u0026#39;,\r},\rsubscribers: [\r{\rsubscriptionType: \u0026#39;SNS\u0026#39;,\raddress: awsBudgetTopic.topicArn,\r},\r],\r},\r],\r};\rconst baseBudget = new budgets.CfnBudget(this, \u0026#39;BaseAwsBudget\u0026#39;, cfnBudgetProps) ","permalink":"https://blog.rstu.xyz/posts/aws-budget-in-cdk/","summary":"Create an AWS Budget in CDK","title":"AWS Budgets in CDK"},{"content":"Try to use short lived credentials when using clouds GitHub\u0026rsquo;s documentation outlines the recommendation to use OIDC functionality between various cloud providers, this allows for the use of short lived credentials as opposed to statically stored secrets which need to be manually created and are prone to proliferation.\nWhen using Github repos to define parts of your AWS configuration, rather than use the manual method, a better approach is to use a CloudFormation template. A CloudFormation template can be used to create a CloudFormation stack in your AWS account to quickly form the OIDC connection between the accounts IAM identity provider feature and a specific repo, allowing for secure exchange of credentials between the pair of entities.\nPay attention to, and edit, ManagedPolicyArns section where it is recommended to scope this to the least privilege needed.\nI\u0026rsquo;d also recommend reading through this post from Rezonate and understand the risks with misconfiguation of this role.\nCloudformation template AWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39;\rDescription: Template to create OIDC Connection\rParameters:\rGitHubOwner:\rType: String\rDescription: Enter Github repo owner\rGitHubRepo:\rType: String\rDescription: Enter Github repo name\rResources:\rIamOidcIdentityProvider:\rType: AWS::IAM::OIDCProvider\rProperties: ClientIdList: - sts.amazonaws.com\rTags: - Key: \u0026#39;Consumer\u0026#39;\rValue: !Sub\r- \u0026#39;Github Actions access for https://github.com/${RepoOwner}/${RepoName}\u0026#39;\r- RepoOwner: !Ref GitHubOwner\rRepoName: !Ref GitHubRepo\rThumbprintList: - 6938fd4d98bab03faadb97b34396831e3780aea1\rUrl: https://token.actions.githubusercontent.com\rIamOidcIdpRole:\rType: AWS::IAM::Role\rProperties:\rRoleName: GithubOidcRole\rDescription: Provides administrator access\rTags: - Key: \u0026#39;Consumer\u0026#39;\rValue: !Sub\r- \u0026#39;Github Actions access for https://github.com/${RepoOwner}/${RepoName}\u0026#39;\r- RepoOwner: !Ref GitHubOwner\rRepoName: !Ref GitHubRepo\rAssumeRolePolicyDocument:\rVersion: \u0026#34;2012-10-17\u0026#34;\rStatement:\r- Effect: Allow\rPrincipal:\rFederated: !Sub\r- \u0026#39;arn:aws:iam::${AccountID}:oidc-provider/token.actions.githubusercontent.com\u0026#39;\r- AccountID: !Ref AWS::AccountId Action: sts:AssumeRoleWithWebIdentity\rCondition:\rStringLike:\rtoken.actions.githubusercontent.com:sub: !Sub\r- repo:${RepoOwner}/${RepoName}:*\r- RepoOwner: !Ref GitHubOwner\rRepoName: !Ref GitHubRepo\rStringEquals:\rtoken.actions.githubusercontent.com:aud: sts.amazonaws.com\rManagedPolicyArns:\r- arn:aws:iam::aws:policy/AdministratorAccess Adding to your automated workflows using Github Actions After the CloudFormation stack is installed you can now use the aws-actions/configure-aws-credentials action to transparently call for short lived credentials to be used in your workflows using the many AWS APIs, or perhaps deploy CDK deployments straight from GitHub.\n- name: Configure AWS Credentials\ruses: aws-actions/configure-aws-credentials@v1-node16\rwith:\rrole-to-assume: arn:aws:iam::112233445566:role/GithubOidcRole\rrole-session-name: GitHubActions-${{ github.run_id }}\raws-region: eu-west-1 ","permalink":"https://blog.rstu.xyz/posts/github-aws-oidc-cloudformation/","summary":"Quickly integrating AWS and GitHub using OIDC and CloudFormation","title":"AWS/GitHub OIDC CloudFormation"}]