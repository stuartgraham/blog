[{"content":"A different way of looking at web apps In April 2022, AWS quietly announced support for Function URLs for Lambda. Function URLs allows for innovation of the function using a generated URL. You can use this run dynamic back end code and return JSON or synthesised HTML, using a template engine like Jinja. While AWS try not to undercut their API Gateway service, this service is really useful for complex web applications right through to very small utility applications. Using the AWS free tier carefully you can host web applications for close-to-free, so its well worth investigating.\nOne problem you will run again is that you may want to run these with an easy to remember URL and to do so with a SSL certificate to match this name, this is where Cloudfront and Certificate Manager comes in.\nThe Lambda Function You can build out a Lambda function in CDK in a standard way, in this example I am building a Python based function using some self created layers for Jinja2 and Requests.\nconst WebInterfaceFunction = new lambda.Function(this, \u0026#39;WebInterfaceFunction\u0026#39;, { code: lambda.Code.fromAsset(path.join(__dirname, \u0026#39;../lambda/web-interface\u0026#39;)), handler: \u0026#39;main.handler\u0026#39;, layers: [simpleJsonLayer, requestsLayer, jinja2Layer], runtime: lambda.Runtime.PYTHON_3_9, timeout: cdk.Duration.seconds(3), architecture: lambda.Architecture.ARM_64, environment: { DYNAMODB_TABLE : webAppTable.tableName }, logRetention: logs.RetentionDays.ONE_WEEK, }); Add a Function URL Now add the Function URL to the function, in this case I am running with no auth, meaning anyone can call for the function. Function URLs also support IAM SigV4 authentication if you have this requirement.\nconst WebInterfaceFunctionUrl = WebInterfaceFunction.addFunctionUrl({ authType: lambda.FunctionUrlAuthType.NONE, }); A point to note here is that Cloudfront has a lot of requirements on US-EAST-1 region whilst you may deploy this function in a region closer to home. A way to mitigate this is to post the generated URL to a SSM Parameter for later reference in a US-EAST-1 stack that will deploy Cloudfront. CDK SSM Parameters do not support region specificity so you can mitigate this by using the @pepperize/cdk-ssm-parameters-cross-region library. In this example I wrangle the host name from the tokenised URL and sent it to a region specific SSM parameter using the aforementioned library.\nconst functionHostUrl = cdk.Fn.select(2, cdk.Fn.split(\u0026#39;/\u0026#39;, WebInterfaceFunctionUrl.url)); new ssmcross.StringParameter(this, \u0026#34;WebInterfaceFunctionHostUrlSsmParam\u0026#34;, { region: \u0026#34;eu-west-1\u0026#34;, parameterName: \u0026#34;/webapp/functionurlhost\u0026#34;, stringValue: functionHostUrl, }); The Cloudfront Distribution Now we have a function with an URL hosted in eu-west-1, lets give it a friendly name, a certificate and a Cloudfront distrubution.\nIn this example I have manually created the ACM certificate and referencing the ARN as an environment variable, you can use CDK to do this automatically at build time.\nconst arn : string = process.env.CERTIFICATE_ARN!; const webAppAcmCertificate = acm.Certificate.fromCertificateArn(this, \u0026#39;WebAppAcmCertificate\u0026#39;, arn); The we grab the SSM parameter from EU-WEST-1 using the same library as above.\nconst originUrl = ssmcross.StringParameter.fromStringParameterName(this, \u0026#34;OriginUrl\u0026#34;, \u0026#34;eu-west-1\u0026#34;, \u0026#34;/webapp/functionurlhost\u0026#34;); Lastly we build the Cloudfront distribution, target the Function URL and disabled caching (my function is all dynamic content).\nconst busCloudfrontDistro = new cloudfront.Distribution(this, \u0026#39;busCFDistribution\u0026#39;, { defaultBehavior: { origin: new origins.HttpOrigin(originUrl.stringValue), cachePolicy: cloudfront.CachePolicy.CACHING_DISABLED }, domainNames: [\u0026#39;webapp.rstu.xyz\u0026#39;], certificate: webAppAcmCertificate }); ","permalink":"https://blog.rstu.xyz/posts/cdk-cloudfront-to-lambda-function/","summary":"Put Cloudfront infront of Lambda Function URLs using CDK","title":"Cloudfront and Lambda Function URLs"},{"content":"Automate budget visibility when using cloud A good starting position with any new AWS account is to decide a budget for spend and to get notifications in place as you meet, approach or exceed this threshold. AWS provide some predictive analysis of you spend patterns too and can catch early problems before they spiral into bill shock and you are contacting their support teams with the begging bowl.\nHere is a snippet to quickly set up a $100 budget in CDK.\nconst awsBudgetTopic = new sns.Topic(this, \u0026#39;BudgetSnsTopic\u0026#39;, { displayName: \u0026#39;My AWS Budget\u0026#39;, }); awsBudgetTopic.addSubscription(new subscriptions.EmailSubscription( \u0026#39;joe@bloggs.com\u0026#39; )) const cfnBudgetProps : budgets.CfnBudgetProps = { budget: { timeUnit: \u0026#39;MONTHLY\u0026#39;, budgetType: \u0026#39;COST\u0026#39;, budgetName: \u0026#39;Base Budget\u0026#39;, budgetLimit: { amount: 100, unit: \u0026#39;USD\u0026#39;, } }, notificationsWithSubscribers: [ { notification: { notificationType: \u0026#39;ACTUAL\u0026#39;, comparisonOperator: \u0026#39;GREATER_THAN\u0026#39;, threshold: 80, thresholdType: \u0026#39;PERCENTAGE\u0026#39;, }, subscribers: [ { subscriptionType: \u0026#39;SNS\u0026#39;, address: awsBudgetTopic.topicArn, }, ], }, ], }; const baseBudget = new budgets.CfnBudget(this, \u0026#39;BaseAwsBudget\u0026#39;, cfnBudgetProps) ","permalink":"https://blog.rstu.xyz/posts/aws-budget-in-cdk/","summary":"Create an AWS Budget in CDK","title":"AWS Budgets in CDK"},{"content":"Try to use short lived credentials when using clouds GitHub\u0026rsquo;s documentation outlines the recommendation to use OIDC functionality between various cloud providers, this allows for the use of short lived credentials as opposed to statically stored secrets which need to be manually created and are prone to proliferation.\nWhen using Github repos to define parts of your AWS configuration, rather than use the manual method, a better approach is to use a CloudFormation template. A CloudFormation template can be used to create a CloudFormation stack in your AWS account to quickly form the OIDC connection between the accounts IAM identity provider feature and a specific repo, allowing for secure exchange of credentials between the pair of entities.\nPay attention to, and edit, ManagedPolicyArns section where it is recommended to scope this to the least privilege needed.\nCloudformation template AWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39; Description: Template to create OIDC Connection Parameters: GitHubOwner: Type: String Description: Enter Github repo owner GitHubRepo: Type: String Description: Enter Github repo name Resources: IamOidcIdentityProvider: Type: AWS::IAM::OIDCProvider Properties: ClientIdList: - sts.amazonaws.com Tags: - Key: \u0026#39;Consumer\u0026#39; Value: !Sub - \u0026#39;Github Actions access for https://github.com/${RepoOwner}/${RepoName}\u0026#39; - RepoOwner: !Ref GitHubOwner RepoName: !Ref GitHubRepo ThumbprintList: - 6938fd4d98bab03faadb97b34396831e3780aea1 Url: https://token.actions.githubusercontent.com IamOidcIdpRole: Type: AWS::IAM::Role Properties: RoleName: GithubOidcRole Description: Provides administrator access Tags: - Key: \u0026#39;Consumer\u0026#39; Value: !Sub - \u0026#39;Github Actions access for https://github.com/${RepoOwner}/${RepoName}\u0026#39; - RepoOwner: !Ref GitHubOwner RepoName: !Ref GitHubRepo AssumeRolePolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: Allow Principal: Federated: !Sub - \u0026#39;arn:aws:iam::${AccountID}:oidc-provider/token.actions.githubusercontent.com\u0026#39; - AccountID: !Ref AWS::AccountId Action: sts:AssumeRoleWithWebIdentity Condition: StringLike: token.actions.githubusercontent.com:sub: !Sub - repo:${RepoOwner}/${RepoName}*:* - RepoOwner: !Ref GitHubOwner RepoName: !Ref GitHubRepo StringEquals: token.actions.githubusercontent.com:aud: sts.amazonaws.com ManagedPolicyArns: - arn:aws:iam::aws:policy/AdministratorAccess Adding to your automated workflows using Github Actions After the CloudFormation stack is installed you can now use the aws-actions/configure-aws-credentials action to transparently call for short lived credentials to be used in your workflows using the many AWS APIs, or perhaps deploy CDK deployments straight from GitHub.\n- name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v1-node16 with: role-to-assume: arn:aws:iam::112233445566:role/GithubOidcRole role-session-name: GitHubActions-${{ github.run_id }} aws-region: eu-west-1 ","permalink":"https://blog.rstu.xyz/posts/github-aws-oidc-cloudformation/","summary":"Quickly integrating AWS and GitHub using OIDC and CloudFormation","title":"AWS/GitHub OIDC CloudFormation"}]